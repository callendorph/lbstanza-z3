defpackage z3/Solver :
  import core
  import z3/Wrapper
  import z3/Context
  import z3/Symbols
  import z3/Parameters
  import z3/Statistics
  import z3/Model
  import z3/AST/AST
  import z3/Enums/Z3_lbool
  import z3/Utils

public lostanza deftype SolverFinalizer <: Finalizer :
  ctx:ptr<?>
  value:ptr<?>

lostanza defmethod run (self:ref<SolverFinalizer>) -> ref<False> :
  w_Z3_solver_dec_ref(self.ctx, self.value)
  return false

public lostanza deftype Solver <: Unique :
  ctx:ptr<?>
  value:ptr<?>


public lostanza defn Solver (ctx:ptr<?>, p:ptr<?>) -> ref<Solver> :
  val ret = new Solver{ctx, p}
  w_Z3_solver_inc_ref(ctx, p)
  add-finalizer(new SolverFinalizer{ctx, p}, ret)
  return ret

public lostanza defn Solver (ctx:ref<Context>, p:ptr<?>) -> ref<Solver> :
  return Solver(ctx.value, p)

public lostanza defn Solver (ctx:ref<Context>) -> ref<Solver> :
  val p = w_Z3_mk_solver(ctx.value)
  return Solver(ctx, p)

public lostanza defn Simple-Solver (ctx:ref<Context>) -> ref<Solver> :
  val p = w_Z3_mk_simple_solver(ctx.value)
  return Solver(ctx, p)

public lostanza defn Solver (ctx:ref<Context>, logic:ref<ZSymbol>) -> ref<Solver> :
  val p = w_Z3_mk_solver_for_logic(ctx.value, logic.value)
  return Solver(ctx, p)

; Solver from Tactic

public lostanza defn Solver-From-File (ctx:ref<Context>, fpath:ref<String>) -> ref<Solver> :
  val ret = Solver(ctx)
  w_Z3_solver_from_file(ctx.value, ret.value, addr!(fpath.chars))
  return ret

public lostanza defn Solver-From-String (ctx:ref<Context>, content:ref<String>) -> ref<Solver> :
  val ret = Solver(ctx)
  w_Z3_solver_from_string(ctx.value, ret.value, addr!(content.chars))
  return ret

public lostanza defn serialize-to-string (s:ref<Solver>) -> ref<String> :
  val ret = w_Z3_solver_to_string(s.ctx, s.value)
  return String(ret)

public lostanza defn serialize-to-DIMACS-string (s:ref<Solver>, include-names:ref<True|False>) -> ref<String> :
  val names = to-byte(include-names)
  val ret = w_Z3_solver_to_dimacs_string(s.ctx, s.value, names)
  return String(ret)

public lostanza defn translate (s:ref<Solver>, target:ref<Context>) -> ref<Solver> :
  val p = w_Z3_solver_translate(s.ctx, s.value, target.value)
  return Solver(target.value, p)

public lostanza defn get-help (s:ref<Solver>) -> ref<String> :
  val ret = w_Z3_solver_get_help(s.ctx, s.value)
  return String(ret)

public lostanza defn get-param-descriptors (s:ref<Solver>) -> ref<ParamDescriptors> :
  val ret = w_Z3_solver_get_param_descrs(s.ctx, s.value)
  return ParamDescriptors(s.ctx, ret)

public lostanza defn set-param (s:ref<Solver>, p:ref<Parameters>) -> ref<False> :
  return w_Z3_solver_set_params(s.ctx, s.value, p.value)

public lostanza defn interrupt (s:ref<Solver>) -> ref<False> :
  return w_Z3_solver_interrupt(s.ctx, s.value)

public lostanza defn push (s:ref<Solver>) -> ref<False> :
  return w_Z3_solver_push(s.ctx, s.value)

public lostanza defn pop (s:ref<Solver>, n:ref<Int>) -> ref<False> :
  return w_Z3_solver_pop(s.ctx, s.value, n.value)

public lostanza defn pop (ctx:ref<Context>, s:ref<Solver>) -> ref<False> :
  return pop(s, new Int{1})

public lostanza defn reset (s:ref<Solver>) -> ref<False> :
  return w_Z3_solver_reset(s.ctx, s.value)

public lostanza defn get-num-scopes (s:ref<Solver>) -> ref<Int> :
  val ret = w_Z3_solver_get_num_scopes(s.ctx, s.value)
  return new Int{ret}

public lostanza defn assert-on (s:ref<Solver>, a:ref<AST>) -> ref<False> :
  return w_Z3_solver_assert(s.ctx, s.value, a.value)

public lostanza defn assert-and-track (s:ref<Solver>, a:ref<AST>, p:ref<AST>) -> ref<False> :
  return w_Z3_solver_assert_and_track(s.ctx, s.value, a.value, p.value)

; public lostanza defn get-assertions (s:ref<Solver>) -> ref<Tuple<AST>> :
;   ; @TODO Z3_AST_vector
;   return None

; public lostanza defn get-units (s:ref<Solver>) -> ref<Tuple<AST>> :
;   ; @TODO Z3_AST_vector
;   return None

; public lostanza defn get-trail (s:ref<Solver>) -> ref<Tuple<AST>> :
;   ; @TODO Z3_AST_vector
;   return None

; public lostanza defn get-non-units (s:ref<Solver>) -> ref<Tuple<AST>> :
;   ; @TODO Z3_AST_vector
;   return None

; @TODO - propagation functions.

public lostanza defn check (s:ref<Solver>) -> ref<Z3_lbool> :
  val ret = w_Z3_solver_check(s.ctx, s.value)
  return Z3_lbool(ret)

; public lostanza defn check-assumptions()  AST array

; public lostanza defn get-implied-equalities () AST array
;  get-consequences
; cube

; get-model
public lostanza defn get-model (s:ref<Solver>) -> ref<Model> :
  val ret = w_Z3_solver_get_model(s.ctx, s.value)
  return Model(s.ctx, ret)

public lostanza defn get-proof (s:ref<Solver>) -> ref<AST> :
  val ret = w_Z3_solver_get_proof(s.ctx, s.value)
  return AST(s.ctx, ret)

public lostanza defn get-reason-unknown (s:ref<Solver>) -> ref<String> :
  val ret = w_Z3_solver_get_reason_unknown(s.ctx, s.value)
  return String(ret)

; get-statistics
public lostanza defn get-statistics (s:ref<Solver>) -> ref<Statistics> :
  val ret = w_Z3_solver_get_statistics(s.ctx, s.value)
  return Statistics(s.ctx, ret)


